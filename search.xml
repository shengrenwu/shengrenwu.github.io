<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>移动web</title>
    <url>/2020/04/04/%E6%9D%82/%E7%A7%BB%E5%8A%A8web/</url>
    <content><![CDATA[<h2 id="浏览器"><a href="#浏览器" class="headerlink" title="浏览器"></a>浏览器</h2><a id="more"></a>
<h3 id="pc常见浏览器"><a href="#pc常见浏览器" class="headerlink" title="pc常见浏览器"></a>pc常见浏览器</h3><blockquote>
<p>谷歌, 火狐, 欧朋, ie</p>
</blockquote>
<h3 id="移动端常见浏览器"><a href="#移动端常见浏览器" class="headerlink" title="移动端常见浏览器"></a>移动端常见浏览器</h3><blockquote>
<p>qq浏览器, uc浏览器, 夸克</p>
</blockquote>
<h3 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h3><table>
<thead>
<tr>
<th>浏览器</th>
<th>内核</th>
<th>前缀</th>
</tr>
</thead>
<tbody><tr>
<td>Chrome</td>
<td>Blink</td>
<td>-webkit-</td>
</tr>
<tr>
<td>IE</td>
<td>Trident</td>
<td>-ms-</td>
</tr>
<tr>
<td>FireFox</td>
<td>Gecko</td>
<td>-moz-</td>
</tr>
<tr>
<td>Opera</td>
<td>Blink</td>
<td>-o-</td>
</tr>
<tr>
<td>Safari</td>
<td>Webkit</td>
<td>-webkit-</td>
</tr>
</tbody></table>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote>
<p>国内的一些手机浏览器都是根据webkit修改过来的内核, 兼容移动端主流浏览器, 处理webkit内核浏览器即可</p>
</blockquote>
<h2 id="移动端调试方法"><a href="#移动端调试方法" class="headerlink" title="移动端调试方法"></a>移动端调试方法</h2><ul>
<li>谷歌浏览器模拟手机调试</li>
<li>搭建本地web服务器, 手机和浏览器一个局域网内, 通过手机访问服务器</li>
<li>使用外网服务器, 直接ip或域名访问</li>
</ul>
<h2 id="理想视口"><a href="#理想视口" class="headerlink" title="理想视口"></a>理想视口</h2><blockquote>
<p>meta视口标签</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"viewport"</span> content=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span><br></pre></td></tr></table></figure>
<h2 id="移动端开发选择"><a href="#移动端开发选择" class="headerlink" title="移动端开发选择"></a>移动端开发选择</h2><ol>
<li><p>单独制作移动端页面</p>
<blockquote>
<p>通过判断设备, 如果是移动端浏览器打开的, 则跳转到移动端页面</p>
</blockquote>
</li>
<li><p>响应式页面</p>
<blockquote>
<p>通过判断屏幕宽度来改变样式, 来适应不同终端</p>
</blockquote>
</li>
</ol>
<h2 id="移动端技术"><a href="#移动端技术" class="headerlink" title="移动端技术"></a>移动端技术</h2><ol>
<li>兼容: <blockquote>
<p>移动端浏览器基本以webkit为主, 可以放心使用h5标签和c3样式, 只需要考虑webkit前缀即可</p>
</blockquote>
</li>
<li>初始化: <blockquote>
<p>通过normalize.css同一样式</p>
</blockquote>
</li>
<li>盒模型(c3中的padding和border不会撑大盒模型)<br>box-sizing: border-box</li>
</ol>
<h2 id="特殊样式"><a href="#特殊样式" class="headerlink" title="特殊样式"></a>特殊样式</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>移动端中使用a标签, 点击时背景会高亮, 需要清除, 设置transpatent完成透明</span><br><span class="line">-webkit-tap-highlight-color: transparent;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span> 移动端浏览器默认的外观, 在ios上加上这个属性才能改按钮和输入框自定义样式</span><br><span class="line">-webkit-appearance: none;</span><br><span class="line"></span><br><span class="line"><span class="number">3.</span> 禁止长按页面时的弹出菜单</span><br><span class="line">img, a&#123; -webkit-touch-callout: none &#125;</span><br></pre></td></tr></table></figure>
<h2 id="移动端布局"><a href="#移动端布局" class="headerlink" title="移动端布局"></a>移动端布局</h2><ol>
<li>单独制作移动端页面<blockquote>
<p>flex弹性布局, rem+媒体查询布局, 流式布局</p>
</blockquote>
</li>
<li>响应式<blockquote>
<p>媒体查询, bootstrap</p>
</blockquote>
</li>
</ol>
]]></content>
      <tags>
        <tag>移动web</tag>
      </tags>
  </entry>
  <entry>
    <title>封装vue日历组件</title>
    <url>/2020/03/22/Vue/%E5%B0%81%E8%A3%85vue%E7%BB%84%E4%BB%B6%E5%87%86%E5%A4%87%E6%AD%A5%E9%AA%A4/</url>
    <content><![CDATA[<h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><ol>
<li>创建自己要封装的组件如Cleandar.vue(进行逻辑编写)</li>
<li>创建index.js文件夹, 可存放所有封装好的组件<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 存放组件----组件导入到这个文件</span></span><br><span class="line"><span class="keyword">import</span> Clendar <span class="keyword">from</span> <span class="string">'./Clendar'</span></span><br><span class="line"><span class="comment">// 导出日历组件, 多个组件也可以导出 </span></span><br><span class="line"><span class="keyword">export</span> &#123;   </span><br><span class="line">  Clendar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>创建install文件, 将封装好的组件注册到vue全局<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;Clendar&#125; <span class="keyword">from</span> <span class="string">'./index'</span></span><br><span class="line"><span class="comment">// Vue通过use方法使用自己定义的组件需要一个install方法</span></span><br><span class="line"><span class="keyword">const</span> install = <span class="function"><span class="keyword">function</span>(<span class="params">Vue</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  <span class="comment">// 挂载到全局组件, 就可以通过use进行使用</span></span><br><span class="line">  Vue.component(Clendar.name, Clendar) <span class="comment">// 名字, 内容</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  install</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>在main.js中导入就可以通过Vue.use(Clendar)进行使用了</li>
</ol>
<h3 id="组件的逻辑"><a href="#组件的逻辑" class="headerlink" title="组件的逻辑"></a>组件的逻辑</h3><p>Cleander.vue </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.props参数</span><br><span class="line">2.slot定制插槽</span><br><span class="line">3.event自定义事件</span><br><span class="line"></span><br><span class="line">移动端事件</span><br><span class="line">@touchstart &#x3D; &quot;start&quot;</span><br><span class="line">@touchmove &#x3D; &quot;move&quot;</span><br><span class="line">@touchend &#x3D; &quot;end&quot;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>less</title>
    <url>/2020/03/20/Css/less/</url>
    <content><![CDATA[<h2 id="less"><a href="#less" class="headerlink" title="less"></a>less</h2><a id="more"></a>
<h3 id="嵌套"><a href="#嵌套" class="headerlink" title="嵌套"></a>嵌套</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.div1&#123;</span><br><span class="line">  .div2&#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="amp-本身"><a href="#amp-本身" class="headerlink" title="&amp;本身"></a>&amp;本身</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">.div&#123;</span><br><span class="line">  &amp;:hover&#123;</span><br><span class="line">    <span class="comment">/*div的hover样式*/</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定义变量-‘-符号’-好用"><a href="#定义变量-‘-符号’-好用" class="headerlink" title="定义变量, ‘@符号’(好用)"></a>定义变量, ‘@符号’(好用)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@变量名 : css属性值</span><br><span class="line"></span><br><span class="line">例: @bgc : rgb(<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">使用:</span><br><span class="line">  .div&#123;</span><br><span class="line">    background: @bgc;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="less引入less"><a href="#less引入less" class="headerlink" title="less引入less"></a>less引入less</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">import</span> url(<span class="string">'b.less'</span>)</span><br></pre></td></tr></table></figure>

<h3 id="less常用"><a href="#less常用" class="headerlink" title="less常用"></a>less常用</h3><blockquote>
<p>mixin.less    组件使用: @import ‘../style/mixin’;</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@blue: #3190e8;  </span><br><span class="line">@bc: #e4e4e4;</span><br><span class="line">@fc:#fff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 背景图片地址和大小</span></span><br><span class="line">.bis(@url) &#123; </span><br><span class="line">	background-image: url(@url);</span><br><span class="line">	background-repeat: no-repeat;</span><br><span class="line">	background-size: <span class="number">100</span>% <span class="number">100</span>%;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位全屏</span></span><br><span class="line">.allcover&#123;</span><br><span class="line">	position:absolute;</span><br><span class="line">	top:<span class="number">0</span>;</span><br><span class="line">	right:<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transform上下左右居中</span></span><br><span class="line">.ctt &#123;  </span><br><span class="line">	position: absolute;</span><br><span class="line">	top: <span class="number">50</span>%;</span><br><span class="line">    left: <span class="number">50</span>%;</span><br><span class="line">    transform: translate(<span class="number">-50</span>%, <span class="number">-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//定位上下左右居中</span></span><br><span class="line">.ctp(@width, @height) &#123;  </span><br><span class="line">	position: absolute;</span><br><span class="line">	top: <span class="number">50</span>%;</span><br><span class="line">    left: <span class="number">50</span>%;</span><br><span class="line">    margin-top: -@height/<span class="number">2</span>;</span><br><span class="line">    margin-left: -@width/<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位上下居中</span></span><br><span class="line">.tb &#123;  </span><br><span class="line">	position: absolute;</span><br><span class="line">	top: <span class="number">50</span>%;</span><br><span class="line">    transform: translateY(<span class="number">-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定位左右居中</span></span><br><span class="line">.lr &#123;  </span><br><span class="line">	position: absolute;</span><br><span class="line">	left: <span class="number">50</span>%;</span><br><span class="line">    transform: translateX(<span class="number">-50</span>%);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//宽高</span></span><br><span class="line">.wh(@width, @height)&#123;</span><br><span class="line">	width: @width;</span><br><span class="line">	height: @height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字体大小、行高、字体</span></span><br><span class="line">.ft(@size, @line-height) &#123;  </span><br><span class="line">	font-size: @size;</span><br><span class="line">	line-height:@line-height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//字体大小，颜色</span></span><br><span class="line">.sc(@size, @color)&#123;</span><br><span class="line">	font-size: @size;</span><br><span class="line">	color: @color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//flex 布局和 子元素 对其方式</span></span><br><span class="line">.fj(@type: space-between)&#123;</span><br><span class="line">	display: flex;</span><br><span class="line">	justify-content: @type;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>css媒体查询和栅格系统</title>
    <url>/2020/03/18/Css/%E5%AA%92%E4%BD%93%E6%9F%A5%E8%AF%A2%E5%92%8C%E6%A0%85%E6%A0%BC%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><blockquote>
<p>主要用于页面的响应式布局</p>
</blockquote>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">@media only screen and (min-width: <span class="number">100</span>px) and (max-width: <span class="number">640</span>px)&#123;</span><br><span class="line">  <span class="comment">// 只对屏幕设备有效, 并且屏幕在最小宽度100px,最大宽度640px内时, 指定的样式生效</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="网页的三段不同样式"><a href="#网页的三段不同样式" class="headerlink" title="网页的三段不同样式"></a>网页的三段不同样式</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span><span class="number">-768</span>px: 手机显示器</span><br><span class="line"><span class="number">768</span><span class="number">-992</span>px: ipad</span><br><span class="line">&gt;=<span class="number">1200</span>px: 电脑</span><br></pre></td></tr></table></figure>
<p>简单使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">  .box&#123;</span><br><span class="line">    height: <span class="number">300</span>px;</span><br><span class="line">  &#125;</span><br><span class="line">  @media only screen and (max-width: <span class="number">768</span>px) &#123; <span class="comment">/*手机*/</span></span><br><span class="line">    .box&#123;</span><br><span class="line">      background-color: red;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media only screen and (min-width: <span class="number">768</span>px) and (max-width: <span class="number">992</span>px) &#123;<span class="comment">/*平版*/</span></span><br><span class="line">    .box&#123;</span><br><span class="line">      background-color: blue;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  @media only screen and (min-width: <span class="number">992</span>px) &#123; <span class="comment">/*电脑*/</span></span><br><span class="line">    .box&#123;</span><br><span class="line">      background-color: yellow;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="栅格系统"><a href="#栅格系统" class="headerlink" title="栅格系统"></a>栅格系统</h2><blockquote>
<p>将网页看做列的模式</p>
</blockquote>
<p>制作一个简单栅格系统</p>
<ol>
<li>利用百分比宽度制作不同的元素</li>
<li>利用盒模型巩固栅格系统</li>
<li>使用浮动使元素处于同一行 </li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 制作四列栅格系统</span></span><br><span class="line"></span><br><span class="line">  &lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    .col<span class="number">-1</span>&#123;</span><br><span class="line">        <span class="comment">/* 占一列 */</span></span><br><span class="line">        width: <span class="number">25</span>%;</span><br><span class="line">        <span class="comment">/* 设置padding只能去挤压内容区, 而不撑大盒模型, 否则会将栅格系统打乱 */</span></span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .col<span class="number">-2</span>&#123;</span><br><span class="line">        <span class="comment">/* 占二列 */</span></span><br><span class="line">        width: <span class="number">50</span>%;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .col<span class="number">-3</span>&#123;</span><br><span class="line">        <span class="comment">/* 占三列 */</span></span><br><span class="line">        width: <span class="number">75</span>%;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line">    .col<span class="number">-4</span>&#123;</span><br><span class="line">        <span class="comment">/* 占四列 */</span></span><br><span class="line">        width: <span class="number">100</span>%;</span><br><span class="line">        box-sizing: border-box;</span><br><span class="line">        float: left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    .box&#123;</span><br><span class="line">        height: <span class="number">100</span>px;</span><br><span class="line">        border: 1px solid #000;</span><br><span class="line">        background-color: cornflowerblue;</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;body&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div class="box col-4"&gt;导航占一行&lt;/</span>div&gt;</span><br><span class="line">      &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box col-1"</span>&gt;左导航栏&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div class="box col-3"&gt;右主内容区&lt;/</span>div&gt;</span><br><span class="line">  &lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="媒体查询-栅格系统-Bootsrtap-12列栅格"><a href="#媒体查询-栅格系统-Bootsrtap-12列栅格" class="headerlink" title="媒体查询 + 栅格系统 = Bootsrtap(12列栅格)"></a>媒体查询 + 栅格系统 = Bootsrtap(12列栅格)</h2><p>响应式的手机电脑demo(使用boostrap定义好的会更简单)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">    @media only screen and (max-width: <span class="number">768</span>px) &#123;</span><br><span class="line">        <span class="comment">/* 手机 small */</span></span><br><span class="line">        .col-small<span class="number">-1</span>&#123;</span><br><span class="line">            width: <span class="number">25</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .col-small<span class="number">-2</span>&#123;</span><br><span class="line">            width: <span class="number">50</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .col-small<span class="number">-3</span>&#123;</span><br><span class="line">            width: <span class="number">75</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .col-small<span class="number">-4</span>&#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    @media only screen and (min-width: <span class="number">768</span>px) &#123;</span><br><span class="line">        <span class="comment">/* 电脑 big */</span></span><br><span class="line">        .col-big<span class="number">-1</span>&#123;</span><br><span class="line">            width: <span class="number">25</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .col-big<span class="number">-2</span>&#123;</span><br><span class="line">            width: <span class="number">50</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .col-big<span class="number">-3</span>&#123;</span><br><span class="line">            width: <span class="number">75</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">        .col-big<span class="number">-4</span>&#123;</span><br><span class="line">            width: <span class="number">100</span>%;</span><br><span class="line">            box-sizing: border-box;</span><br><span class="line">            float: left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    .box&#123;</span><br><span class="line">        height: <span class="number">100</span>px;</span><br><span class="line">        border: 1px solid #000;</span><br><span class="line">        background-color: cornflowerblue;</span><br><span class="line">    &#125;</span><br><span class="line">    &lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    &lt;body&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="box col-big-4 col-small-4"&gt;&lt;/</span>div&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"box col-big-1 col-small-4"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="box col-big-3 col-small-4"&gt;&lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/body&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>js高阶函数</title>
    <url>/2020/03/16/js/js%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<h2 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h2><blockquote>
<p>如果一个函数的参数是一个函数 (回调函数) 或者一个函数返回一个函数 (函数科里化)  </p>
</blockquote>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用场景: 写代码时我们希望不破坏原有逻辑而增加一些功能 (aop面向切片编程)</span></span><br><span class="line"><span class="comment">// 定义一个函数, 希望在调用函数之前做一些事情   </span></span><br><span class="line"><span class="keyword">const</span> say = <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'说话'</span>, ...args)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给所有的函数扩展before方法</span></span><br><span class="line"><span class="built_in">Function</span>.prototype.before = <span class="function"><span class="keyword">function</span>(<span class="params">cb</span>) </span>&#123;  <span class="comment">// 高阶函数, 参数是函数并且返回值是函数</span></span><br><span class="line">    <span class="comment">// console.log(this) // 这里指的是调用before的say方法</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123; <span class="comment">// 必须使用箭头函数, 使用function时this不指向say方法</span></span><br><span class="line">      <span class="comment">// 先调用提前传入的before方法</span></span><br><span class="line">      cb()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// console.log(...args) //  "1", "2", "3"  参数传给say方法</span></span><br><span class="line">      <span class="comment">// 在执行say方法</span></span><br><span class="line">      <span class="keyword">this</span>(...args)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用say之前的逻辑, 返回一个新函数</span></span><br><span class="line"><span class="keyword">let</span> newSay = say.before(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'给say调用之前添加的方法'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//  newSay执行指的是say.before执行后返回的函数, 当传递参数时是给say.before执行后的函数传参</span></span><br><span class="line">newSay(<span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>)  <span class="comment">// 执行结果: 给say调用之前添加的方法 说话</span></span><br></pre></td></tr></table></figure>

<h2 id="函数科里化"><a href="#函数科里化" class="headerlink" title="函数科里化"></a>函数科里化</h2><blockquote>
<p>场景:判断变量的类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 判断一个变量的数据类型</span></span><br><span class="line"><span class="comment">// 判断类型的四种方式 constructor instanceof typeof Object.prototype.toString.call</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkType</span>(<span class="params">content, type</span>)</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Object</span>.prototype.toString.call(content) === <span class="string">`[object <span class="subst">$&#123;type&#125;</span>]`</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> bool = checkType(<span class="string">'hello'</span>, <span class="string">'String'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(bool) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>以上代码虽然可以判断变量数据类型, 但是存在不足</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>es6面向对象</title>
    <url>/2020/03/13/js/es6%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="es6创建类"><a href="#es6创建类" class="headerlink" title="es6创建类"></a>es6创建类</h2><a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es5创建类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fn</span></span>&#123;</span><br><span class="line">    <span class="comment">// 也可以给实例创建属性</span></span><br><span class="line">    y = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等价于之前的构造函数体</span></span><br><span class="line">    <span class="keyword">constructor</span>(n=1, m=1) &#123;</span><br><span class="line">      <span class="keyword">this</span>.x = n + m		</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//  方法直接写, 就是添加在类原形上的方法</span></span><br><span class="line">    getX()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.x)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前边设置static的, 把当前Fn当做普通对象设置键值对, 只能Fn.gety()使用</span></span><br><span class="line">    <span class="keyword">static</span> gety()&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'类的私有方法'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态属性(只有Fn能使用)</span></span><br><span class="line">    <span class="keyword">static</span> one = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 创建实例对象</span></span><br><span class="line"><span class="keyword">let</span> f1 = <span class="keyword">new</span> Fn(<span class="number">10</span>, <span class="number">20</span>)</span><br><span class="line"><span class="built_in">console</span>.log(f1.one, Fn.one) <span class="comment">// undefined 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Fn()  // 当做普通函数执行会报错</span></span><br><span class="line"><span class="built_in">console</span>.dir(Fn)  <span class="comment">// </span></span><br><span class="line"><span class="built_in">console</span>.log(f1) <span class="comment">// &#123;x:30, y:100&#125;</span></span><br></pre></td></tr></table></figure>
<h2 id="类的继承"><a href="#类的继承" class="headerlink" title="类的继承"></a>类的继承</h2>]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>es5面向对象</title>
    <url>/2020/03/13/js/es5%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="构造函数创建对象"><a href="#构造函数创建对象" class="headerlink" title="构造函数创建对象"></a>构造函数创建对象</h2><a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Student构造函数, es6中叫Student类</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// 通过new调用的this指向实例, name和age都是实例的属性, 构造函数不能直接调用</span></span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line">  <span class="keyword">this</span>.age = age</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不好的创建方法方式,方法是共用的, s1.err不等于s2.err 也就是指向不同的内存地址,相同的方法会占用内存</span></span><br><span class="line">  <span class="keyword">this</span>.err = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 原型创建属性</span></span><br><span class="line">Student.prototype.type = <span class="string">'人类'</span></span><br><span class="line"><span class="comment">// 原型创建方法 所有实例的方法都指向这一个方法</span></span><br><span class="line">Student.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'吃东西'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实例</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="keyword">new</span> Student(<span class="string">'xx'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="keyword">new</span> Student(<span class="string">'yy'</span>, <span class="number">19</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//  1.instanceof本意就是检测实例是否隶属于某个类, 所以可以使用instanceof检测引用数据类型</span></span><br><span class="line"><span class="built_in">console</span>.log(s1 <span class="keyword">instanceof</span> Student) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.将方法存放在prototype对象上的好处</span></span><br><span class="line"><span class="built_in">console</span>.log(s1.eat === s2.eat) <span class="comment">// true  相同的方法都在Student原型上, 指向同一个内存地址</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 构造函数的原型上有constructor属性指向构造函数本身</span></span><br><span class="line"><span class="built_in">console</span>.log(Student.prototype.constructor === Student) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="实例原型关系图"><a href="#实例原型关系图" class="headerlink" title="实例原型关系图"></a>实例原型关系图</h3><img src="/images/prototype.png"/>
> 原型链: 实例查找方法时, 自身如果没有, 就会通过__proto__向构造函数的原型上查找某方法(实例调用方法时会先找私有属性, 找不到就回去找共有属性)

<ol>
<li>new 构造符做了哪些事情?<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">obj.__proto__ = S.prototype</span><br><span class="line">S.call(obj)</span><br><span class="line"><span class="keyword">return</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line">创建一个空对象</span><br><span class="line"><span class="keyword">this</span>指向这个对象</span><br><span class="line">执行构造函数中的代码</span><br><span class="line">返回新对象</span><br></pre></td></tr></table></figure></li>
<li>isPrototypeOf()<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">isPrototypeOf方法用来判断某个prototype对象和某个实例之间的关系</span><br><span class="line"></span><br><span class="line">  alert(Student.prototype.isPrototypeOf(s1)) <span class="comment">//true</span></span><br><span class="line">  alert(Student.prototype.isPrototypeOf(s2)) <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li>
<li>hasOwnProperty()<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">每一个实例都有一个hasOwnProperty方法, 用于判断某一个属性是不是构造函数内的属性</span><br><span class="line">该方法会忽略掉那些从原型链定义的属性。因为hasOwnProperty是 JavaScript 中唯一一个处理属性但是不查找原型链的函数。</span><br><span class="line">  <span class="comment">// 检测属性</span></span><br><span class="line">  <span class="built_in">console</span>.log(s1.hasOwnProperty(<span class="string">'name'</span>)); <span class="comment">// true</span></span><br><span class="line">  <span class="built_in">console</span>.log(s2.hasOwnProperty(<span class="string">'type'</span>)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></li>
<li>in运算符<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 检测属性, 不管是构造函数内部还是原型上的属性, 只要有就是true</span></span><br><span class="line">　　alert(<span class="string">"name"</span> <span class="keyword">in</span> s1) <span class="comment">// true</span></span><br><span class="line">　　alert(<span class="string">"type"</span> <span class="keyword">in</span> s2) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>面向对象</tag>
      </tags>
  </entry>
  <entry>
    <title>发布订阅设计模式</title>
    <url>/2020/03/12/%E6%9D%82/%E5%8F%91%E5%B8%83%E8%AE%A2%E9%98%85%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<blockquote>
<p>发布订阅</p>
</blockquote>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<!--more-->
<h2 id="发布订阅和DOM2事件池机制"><a href="#发布订阅和DOM2事件池机制" class="headerlink" title="发布订阅和DOM2事件池机制"></a>发布订阅和DOM2事件池机制</h2><h3 id="DOM0和DOM2事件绑定的区别"><a href="#DOM0和DOM2事件绑定的区别" class="headerlink" title="DOM0和DOM2事件绑定的区别"></a>DOM0和DOM2事件绑定的区别</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 语法上的区别</span><br><span class="line">  - box.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  - box.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br><span class="line"><span class="number">2.</span> 运行机制上的区别</span><br><span class="line">  - DOM0就是给元素绑定方法(有效的绑定方法只有一个)</span><br><span class="line">  - DOM2是基于事件池机制完成, 每增加一个绑定的方法, 都会往事件池中存放一个...事件触发会依次执行事件池中的方法</span><br><span class="line">  =&gt; 发布订阅其实就是模拟的事件池机制(可以给同一个元素的某个事件绑定多个不同的方法)  </span><br><span class="line"><span class="number">3.</span> DOM2中可以给一些特殊的事件类型绑定方法, 这些DOM0不支持</span><br><span class="line">   DOMContentLoaded(dom结构加载完执行), transitioned</span><br></pre></td></tr></table></figure>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2>]]></content>
      <tags>
        <tag>发布订阅</tag>
      </tags>
  </entry>
  <entry>
    <title>vue生命周期</title>
    <url>/2020/03/11/Vue/vue%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<h3 id="生命周期钩子函数"><a href="#生命周期钩子函数" class="headerlink" title="生命周期钩子函数"></a>生命周期钩子函数</h3><a id="more"></a>
<table>
<thead>
<tr>
<th align="left">生命周期钩子</th>
<th align="left">组件装态</th>
<th align="left">实践</th>
</tr>
</thead>
<tbody><tr>
<td align="left">beforeCreate</td>
<td align="left">初始化界面前, data未完成, 值为undefined</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">created</td>
<td align="left">初始化界面后, Vue实例创建完成, 可以访问data, computed, watch, methods上的方法和属性, 但是并未挂载dom, 不能访问$el的属性</td>
<td align="left">进行axios数据请求</td>
</tr>
<tr>
<td align="left">beforeMount</td>
<td align="left">渲染dom前, 会找到对应的template, 并编译成render函数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">mounted</td>
<td align="left">实例挂载到DOM上, 可以使用$refs访问DOM节点</td>
<td align="left">获取vNode信息和操作, ajax请求, echarts数据请求</td>
</tr>
<tr>
<td align="left">beforeUpdate</td>
<td align="left">响应式数据更新时调用, 发生在虚拟DOM打补丁之前</td>
<td align="left">适合在更新之前访问现有的DOM, 比如手动移出已添加的事件监听器</td>
</tr>
<tr>
<td align="left">updated</td>
<td align="left">虚拟DOM重新渲染和打补丁之后调用, 组件DOM已经更新, 可执行依赖于DOM的操作</td>
<td align="left">避免在这个钩子函数中操作数据, 可能会陷入死循环</td>
</tr>
<tr>
<td align="left">beforeDestroy</td>
<td align="left">实例销毁之前调用, 这一步实例的方法都还可用</td>
<td align="left">常用与销毁定时器, 解绑全局事件, 销毁插件对象等操作</td>
</tr>
<tr>
<td align="left">destroyed</td>
<td align="left">实例销毁后调用, 调用后, Vue实例指示的所有东西都会解绑定, 所有的事件监听器会被移出, 所有的子实例也会被销毁</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="单个组件生命周期"><a href="#单个组件生命周期" class="headerlink" title="单个组件生命周期"></a>单个组件生命周期</h3><ol>
<li>初始化组件时, 仅执行beforeCreate/Created/beforeMount/Mounted四个钩子函数</li>
<li>当data中定义的变量改变时会执行beforeUpdate/updated钩子函数</li>
<li>档切换组件(当前组件为缓存时), 会执行beforeDestory/destroyed两个钩子函数</li>
<li>初始化和销毁时的生命周期钩子函数只会执行一次, beforeUpdate/update可执行多次</li>
</ol>
<h3 id="父子组件的生命周期"><a href="#父子组件的生命周期" class="headerlink" title="父子组件的生命周期"></a>父子组件的生命周期</h3><p>初始化组件时:<br> –f–beforeCreate<br> –f–created<br> –f–beforeMount<br> –c–beforeCreate接收不到props中的数据–data未初始化<br> –c–createdchild<br> –c–beforeMount<br> –c–mounted<br> –f–mounted</p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>vuex使用</title>
    <url>/2020/03/08/Vue/vuex/</url>
    <content><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式, 集中式存储所有组件状态(数据), 方便组件之间的数据共享</p>
</blockquote>
<a id="more"></a>
<h3 id="Vuex好处"><a href="#Vuex好处" class="headerlink" title="Vuex好处"></a>Vuex好处</h3><ol>
<li>能够在vuex中集中管理共享的数据, 易于开发和后期维护</li>
<li>能够高效地实现组件之间的数据共享, 提高开发效率</li>
<li>存储在vuex中的数据都是响应式的, 能够实时保持数据与页面的同步</li>
</ol>
<h3 id="什么时候使用vuex"><a href="#什么时候使用vuex" class="headerlink" title="什么时候使用vuex"></a>什么时候使用vuex</h3><ol>
<li>构建大型单页面应用</li>
<li>来自不同组件的行为需要变更同一状态</li>
</ol>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><ol>
<li>main.js<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.导入store</span></span><br><span class="line"><span class="keyword">import</span> store <span class="keyword">from</span> <span class="string">'./store/index'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">  store,  <span class="comment">// 2.注册</span></span><br><span class="line">  render: <span class="function"><span class="params">h</span> =&gt;</span> h(App)</span><br><span class="line">&#125;).$mount(<span class="string">'#app'</span>)</span><br></pre></td></tr></table></figure></li>
<li>store/index.js一般的书写形式<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"><span class="comment">// 在vuex中请求数据</span></span><br><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">'axios'</span></span><br><span class="line"></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    <span class="comment">// 定义数据</span></span><br><span class="line">    data: [],</span><br><span class="line">    count: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="comment">// 定义存值的同步方法</span></span><br><span class="line">    initData(state, data) &#123;</span><br><span class="line">      state.data = data</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="comment">// axios异步请求</span></span><br><span class="line">    getDate(context) &#123;</span><br><span class="line">      axios.get(<span class="string">'/data'</span>).then(<span class="function">(<span class="params">&#123; data &#125;</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 提交给mutations做数据的处理</span></span><br><span class="line">        context.commit(<span class="string">'initData'</span>, data)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="comment">// 根据一定的条件对数据进行处理</span></span><br><span class="line">    infodata(state) &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'默认情况'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.data</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'选中状态的值'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.data.filter(<span class="function"><span class="params">val</span> =&gt;</span> x.flag === <span class="literal">true</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (<span class="string">'未选中状态的值'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> state.data.filter(<span class="function"><span class="params">val</span> =&gt;</span> x.flag === <span class="literal">false</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 防止以上报错</span></span><br><span class="line">      <span class="keyword">return</span> state.data</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// data数据的长度</span></span><br><span class="line">    dataLength(state) &#123;</span><br><span class="line">      <span class="keyword">return</span> state.data.length</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="组件使用"><a href="#组件使用" class="headerlink" title="组件使用"></a>组件使用</h2></li>
</ol>
<h3 id="组件直接使用state-getters-mutations-actions"><a href="#组件直接使用state-getters-mutations-actions" class="headerlink" title="组件直接使用state, getters, mutations, actions"></a>组件直接使用state, getters, mutations, actions</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用state</span></span><br><span class="line">&lt;p&gt; 使用方法一:&#123;&#123;$store.state.count&#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt; 使用方法二: &#123;&#123;count&#125;&#125; &lt;/</span>p&gt;</span><br><span class="line">computed:&#123;</span><br><span class="line">   count()&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.$store.state.count</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用getters</span></span><br><span class="line">&lt;p&gt; 使用方法一:&#123;&#123;$store.getters.dataLength&#125;&#125; &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">&lt;p&gt; 使用方法二: &#123;&#123;dataLength&#125;&#125; &lt;/</span>p&gt;</span><br><span class="line">computed:&#123;</span><br><span class="line">   dataLength()&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">this</span>.$store.getters.dataLength</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// -------------------------------------------------------</span></span><br><span class="line"></span><br><span class="line">&lt;button @click=<span class="string">"btn1"</span>&gt;同步+<span class="number">1</span>&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button @click="btn2"&gt;异步+3&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">methods:&#123;</span><br><span class="line">  <span class="comment">// 触发mutations</span></span><br><span class="line">  btn1() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.commit(<span class="string">'mutations中的同步方法'</span>, &lt;可选参数&gt;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 触发actions</span></span><br><span class="line">  btn2() &#123;</span><br><span class="line">    <span class="keyword">this</span>.$store.dispatch(<span class="string">'actions中的异步方法Async'</span>, &lt;可选参数&gt;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="组件借用辅助函数批量使用"><a href="#组件借用辅助函数批量使用" class="headerlink" title="组件借用辅助函数批量使用"></a>组件借用辅助函数批量使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 组件引入辅助函数</span></span><br><span class="line"><span class="keyword">import</span> &#123; mapState, mapGetters, mapMutations, mapActions &#125; <span class="keyword">from</span> <span class="string">'vuex'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// state与getters使用</span></span><br><span class="line">computed: &#123;</span><br><span class="line">    ...mapState([<span class="string">'count'</span>]),  <span class="comment">// 页面直接使用&#123;&#123;count&#125;&#125;</span></span><br><span class="line">    ...mapGetters([<span class="string">'dataLength'</span>]) <span class="comment">// 页面直接使用&#123;&#123;dataLength&#125;&#125; </span></span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line"><span class="comment">// mutations和actions使用</span></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="comment">// 同步事件使用 @click="syncHandle1(可选参数)"</span></span><br><span class="line">  ...mapMutations([<span class="string">'syncHandle1'</span>, <span class="string">'syncHandle2'</span>]),</span><br><span class="line">  <span class="comment">// 异步事件使用 @click="asyncHandle1(可选参数)"</span></span><br><span class="line">  ...mapActions([<span class="string">'asyncHandle1'</span>, <span class="string">'asyncHandle2'</span>])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vuex核心属性"><a href="#vuex核心属性" class="headerlink" title="vuex核心属性"></a>vuex核心属性</h2><h3 id="state"><a href="#state" class="headerlink" title="state"></a>state</h3><blockquote>
<p>数据源</p>
</blockquote>
<h3 id="getters"><a href="#getters" class="headerlink" title="getters"></a>getters</h3><blockquote>
<p>不会修改state中的数据, 只是起到包装数据的作用。类似于计算属性, 返回值会被缓存</p>
</blockquote>
<h3 id="mutations"><a href="#mutations" class="headerlink" title="mutations"></a>mutations</h3><blockquote>
<p>更改state数据的唯一方法, 必须是同步函数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 可以使用常量命名mutations事件类型</span></span><br><span class="line">mutations: &#123;</span><br><span class="line">  SET_SIZE: <span class="function">(<span class="params">state, size</span>) =&gt;</span> &#123;</span><br><span class="line">    state.size = size</span><br><span class="line">    Cookies.set(<span class="string">'size'</span>, size)</span><br><span class="line">  &#125;,</span><br><span class="line">  CLOSE_SIDEBAR: <span class="function">(<span class="params">state, withoutAnimation</span>) =&gt;</span> &#123;</span><br><span class="line">    Cookies.set(<span class="string">'sidebarStatus'</span>, <span class="number">0</span>)</span><br><span class="line">    state.sidebar.opened = <span class="literal">false</span></span><br><span class="line">    state.sidebar.withoutAnimation = withoutAnimation</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h3><blockquote>
<p>actions提交的是mutations, 而不是直接变更状态</p>
</blockquote>
<blockquote>
<p>actions可以包含任意的异步操作(定时器, promise)</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过promise来知道actions什么时候结束</span></span><br><span class="line">actionA (&#123; commit &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      commit(<span class="string">'Mutation1'</span>)</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 组件使用</span></span><br><span class="line"><span class="keyword">this</span>.$store.dispatch(<span class="string">'actionA'</span>).then( <span class="function"><span class="params">_</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 另外一个actionB</span></span><br><span class="line">actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> dispatch(<span class="string">'actionA'</span>).then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    commit(<span class="string">'Mutation2'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async/await</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">actions: &#123;</span><br><span class="line">  <span class="keyword">async</span> actionA (&#123; commit &#125;) &#123;</span><br><span class="line">    commit(<span class="string">'getData'</span>, <span class="keyword">await</span> axios.get(<span class="string">'/'</span>))</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">async</span> actionB (&#123; dispatch, commit &#125;) &#123;</span><br><span class="line">    <span class="keyword">await</span> dispatch(<span class="string">'actionA'</span>) <span class="comment">// 等待 actionA 完成</span></span><br><span class="line">    commit(<span class="string">'gotOtherData'</span>, <span class="keyword">await</span> getOtherData())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="modules"><a href="#modules" class="headerlink" title="modules"></a>modules</h3><blockquote>
<p>将store分割成模块</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;,</span><br><span class="line">  getters: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> moduleB = &#123;</span><br><span class="line">  state: &#123; ... &#125;,</span><br><span class="line">  mutations: &#123; ... &#125;,</span><br><span class="line">  actions: &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  modules: &#123;</span><br><span class="line">    a: moduleA,</span><br><span class="line">    b: moduleB</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">store.state.a <span class="comment">// -&gt; moduleA 的状态</span></span><br><span class="line">store.state.b <span class="comment">// -&gt; moduleB 的状态</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>引入css的两种方式</title>
    <url>/2020/03/05/Css/%E5%BC%95%E5%85%A5css%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="link"><a href="#link" class="headerlink" title="link"></a>link</h2><blockquote>
<p>将css引入到页面<br><code>&lt;link href=&quot;地址&quot; rel=&quot;stylesheet&quot; type=&quot;text/css&quot; /&gt;</code></p>
</blockquote>
<a id="more"></a>
<h2 id="import"><a href="#import" class="headerlink" title="@import"></a>@import</h2><blockquote>
<p>将css引入到css<br><code>@import url(&quot;css/style.css&quot;)</code></p>
</blockquote>
<h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ul>
<li>link<ul>
<li>属于XHTML标签, 还有rel连接属性等</li>
<li>优先加载CSS文件到页面</li>
</ul>
</li>
<li>@import<ul>
<li>属于CSS, 只能加载CSS</li>
<li>先加载HTML结构在加载CSS文件, 有时候使用@import加载css的页面时会没有样式</li>
</ul>
</li>
</ul>
<p>– 使用link标签</p>
]]></content>
      <categories>
        <category>css</category>
      </categories>
  </entry>
  <entry>
    <title>script和link标签</title>
    <url>/2020/03/05/Html/script%E5%92%8Clink%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<h2 id="script标签"><a href="#script标签" class="headerlink" title="script标签"></a>script标签</h2><a id="more"></a>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul>
<li>必选属性<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">type</td>
<td align="left">声明脚本的MIME类型</td>
</tr>
</tbody></table>
</li>
<li>可选属性<table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">src</td>
<td align="left">规定外部脚本的URL</td>
</tr>
<tr>
<td align="left">defer</td>
<td align="left">对脚本执行进行延迟, 直到页面加载为止</td>
</tr>
<tr>
<td align="left">async</td>
<td align="left">异步执行外部js脚本–加载完js代码立即执行</td>
</tr>
<tr>
<td align="left">charset</td>
<td align="left">在外部脚本中使用的字符编码</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="defer和async区别"><a href="#defer和async区别" class="headerlink" title="defer和async区别"></a>defer和async区别</h4><ul>
<li>defer是只有页面加载完毕才会执行外部js代码</li>
<li>async是只要js代码加载完毕就立即执行<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>理论上放在哪里都是可以的</li>
<li>最好放在body标签闭合之前</li>
</ul>
</li>
</ul>
<h2 id="link标签"><a href="#link标签" class="headerlink" title="link标签"></a>link标签</h2><h3 id="主要属性"><a href="#主要属性" class="headerlink" title="主要属性"></a>主要属性</h3><ul>
<li>rel: 值是”stylesheet”就得到浏览器支持</li>
<li>type: MIME类型</li>
<li>href: 链接文档位置<br><code>&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;theme.css&quot; /&gt;</code></li>
</ul>
]]></content>
      <categories>
        <category>html</category>
      </categories>
  </entry>
  <entry>
    <title>javascript运行机制</title>
    <url>/2020/03/04/js/javascript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="javascript单线程"><a href="#javascript单线程" class="headerlink" title="javascript单线程"></a>javascript单线程</h3><p><a href="https://blog.csdn.net/function__/article/details/80883084" target="_blank" rel="noopener">线程问题</a> </p>
<h3 id="javascript同步异步机制"><a href="#javascript同步异步机制" class="headerlink" title="javascript同步异步机制"></a>javascript同步异步机制</h3><a id="more"></a>
<blockquote>
<p><font color=red><strong>同步</strong>:</font>  在一个线程上(主栈/主任务队列)同一时间只能做一件事, 当事情完成后才能进行下一个事情(先把一个任务进栈执行, 执行完成, 再把下一个任务进栈, 上一个任务出栈)</p>
</blockquote>
<blockquote>
<p><font color=red><strong>异步</strong>:</font>  在主栈中执行一个任务, 但是发现这个任务是一个异步的操作, 会把它移出主栈, 放入等待任务队列中(此时浏览器会分配其他线程监听异步任务是否达到指定的执行时间), 如果主栈任务完成, 监听者会把到达时间的异步任务重新放到主栈中执行</p>
</blockquote>
<p>执行机制如图:<br><img src="/images/execute.jpg" width="400px"/></p>
<h4 id="常见异步"><a href="#常见异步" class="headerlink" title="常见异步"></a>常见异步</h4><ul>
<li>宏任务<ul>
<li>整体代码script</li>
<li>定时器(setTimeout, setInterval)</li>
<li>事件绑定</li>
<li>ajax</li>
<li>回调函数</li>
</ul>
</li>
<li>微任务 <ul>
<li>Promise(async/await)</li>
<li>process.nextTick(callback)</li>
</ul>
</li>
</ul>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><blockquote>
<p>事件循环的顺序, 决定js代码执行的顺序</p>
</blockquote>
<blockquote>
<p>进入整体代码(宏任务)后, 开始第一次循环。接着执行所有的微任务。然后再进入宏任务, 找到其中一个任务队列执行完毕, 再执行所有的微任务。</p>
</blockquote>
<p>代码演示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>整个代码作为宏任务, 进入主线程</p>
</li>
<li><p>先遇到setTimeout, 将他的回调函数注册后分发到宏任务等待队列</p>
</li>
<li><p>然后遇到new Promise立即执行, then函数分发到微任务等待队列</p>
</li>
<li><p>console.log() 立即执行</p>
</li>
<li><p>整体代码script作为第一个宏任务执行结束, 接着执行遇到的微任务, then函数在微任务的等待队列中执行</p>
</li>
<li><p>第一轮事件循环结束, 开始第二轮。从宏任务的等待队列开始, 执行setTimeout中的回调函数</p>
</li>
<li><p>第二轮没有微任务, 之后也没有宏任务, 结束</p>
<p>事件循环, 宏任务, 微任务关系如下图:</p>
<img src="/images/event loop.jpg" width="500px"/>

</li>
</ul>
<h4 id="题目积累"><a href="#题目积累" class="headerlink" title="题目积累"></a>题目积累</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复杂题</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">			</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">        process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">        process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">//  1 7  script整体宏任务 </span></span><br><span class="line"><span class="comment">//  6 8  执行所有微任务</span></span><br><span class="line"><span class="comment">//  9 11   两个setTimeout, 后一个时间短(1000)所以先执行第二个setTimeout宏任务</span></span><br><span class="line"><span class="comment">//  10 12  第二个宏任务的微任务</span></span><br><span class="line"><span class="comment">//  2 4  第一个setTimeout(2000)的宏任务</span></span><br><span class="line"><span class="comment">//  3 5  微任务</span></span><br><span class="line"><span class="comment">//  结束</span></span><br></pre></td></tr></table></figure>

<p>带有async/await</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? reject(<span class="number">100</span>): resolve(<span class="number">200</span>);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">let</span> res = <span class="keyword">await</span> AA();</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 1.先把AA执行，返回一个Promise实例</span></span><br><span class="line"><span class="comment">	 * 2.它会暂时跳出当前正在执行的函数，将后面的代码放到等待队列</span></span><br><span class="line"><span class="comment">	 * 3.主栈暂时空闲</span></span><br><span class="line"><span class="comment">	 * 4.当主栈的其他任务完成，并且AA中的Promise也已经计算完成最后的结果，再把之前的第二步放到等待队列的内容，拿回主栈执行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>有关于setTimeout</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的执行 4 2 3 1</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加阻隔 4 2 1 3</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'W'</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; <span class="number">99999999</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'W'</span>);<span class="comment">//时间 -&gt; 279ms -&gt; 0.279s</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>


<p>async/await<br><code>浏览器是多线程的 -&gt; 可以渲染js, 渲染css</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 start'</span>) <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">await</span> async2()</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async1 end'</span>) <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">async2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'async2'</span>) <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script start'</span>) <span class="comment">// 1</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)  <span class="comment">// 8</span></span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line">async1()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise1'</span>) <span class="comment">// 4</span></span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'promise2'</span>)  <span class="comment">// 6</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'script end'</span>) <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2020/03/04/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote>
<p>触发高频事件后n秒内函数只会执行一次, 如果n秒内高频事件再次被触发, 则重新计算时间</p>
</blockquote>
<blockquote>
<p>触发高频事件时在最后一次事件被触发n秒后执行函数</p>
</blockquote>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 防抖函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      clearTimeout(timer) <span class="comment">// 每当用户输入的时候把前一个setTimeout 清除掉</span></span><br><span class="line">      timer = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args) <span class="comment">// this -&gt; window  因为fn函数是在window下创建的, 需要保证this指向</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取输入框值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!e.target.value) <span class="keyword">return</span> </span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现防抖</span></span><br><span class="line">ipt.addEventListener(<span class="string">'input'</span>, debounce(getValue, <span class="number">2000</span>))</span><br></pre></td></tr></table></figure>
<p>防抖应用场景</p>
<ul>
<li>搜索框</li>
<li>表单验证</li>
<li>按钮提交事件</li>
<li>浏览器窗口缩resize事件<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote>
<p>高频事件触发, 但是在n秒只会执行一次</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>节流会稀释函数的执行频率, 固定时间内只执行一次</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!flag) <span class="keyword">return</span></span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取输入框值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!e.target.value) <span class="keyword">return</span> </span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现节流</span></span><br><span class="line">ipt.addEventListener(<span class="string">'input'</span>, throttle(getValue, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>节流应用场景</p>
<ul>
<li>按钮点击事件</li>
<li>拖拽事件</li>
<li>onScroll</li>
<li>计算鼠标移动距离(onmousemove)</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2020/03/02/js/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="跨域是什么"><a href="#跨域是什么" class="headerlink" title="跨域是什么"></a>跨域是什么</h2><ul>
<li>同源策略请求( 协议,域名,端口号都相同 )</li>
<li>非同源策略请求( 协议,域名,端口号有一个不同就是跨域 )<a id="more"></a>

</li>
</ul>
<h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><blockquote>
<p>script, img, iframe标签中的src属性是没有同源策略限制的, 例如借用CDN使用jquery库</p>
</blockquote>
<pre><code>JQ中使用Jsonp: 请求时添加dataType: &apos;jsonp&apos;属性来指定请求方式
Vue使用Jsonp: 下载jsonp依赖进行jsonp请求
JSONP原理: 前端创建一个回调函数, 然后服务器调用这个函数并且将JSON数据作为参数传递, 完成回调
JSONP总结: 兼容性非常好, 限制就是只能使用get方式发起请求(因为src, href都是资源文件请求), 安全性也存在问题
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用jsonp的方式动态创建script标签实现jsonp跨域请求</span><br><span class="line">// 实现百度搜索关键词的功能</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"input"</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">"btn"</span>&gt;搜索&lt;/button&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"ul"</span> style=<span class="string">"list-style-type: none;padding: 0"</span>&gt;</span><br><span class="line">      &lt;!-- &lt;li&gt;搜索到的值&lt;/li&gt; --&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      // http://api.asilu.com/<span class="comment">#sug-baidu jsonp在线接口</span></span><br><span class="line">      <span class="keyword">function</span> showJsonp(res)&#123;</span><br><span class="line">        console.log(res) // &#123;q: <span class="string">"123"</span>, p: <span class="literal">false</span>, s: Array(10)&#125;</span><br><span class="line">        <span class="built_in">let</span> data = res.s</span><br><span class="line">        // 将res.s中的数据渲染到li标签中</span><br><span class="line">        <span class="built_in">let</span> str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> i =0; i&lt;data.length; i++)&#123;</span><br><span class="line">          str += `&lt;li class=<span class="string">"active"</span>&gt;<span class="variable">$&#123;data[i]&#125;</span>&lt;/li&gt;`</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加到ul标签内部</span><br><span class="line">        ul.innerHTML = str</span><br><span class="line">      &#125;</span><br><span class="line">      btn.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        // 点击搜索时获取输入框的值</span><br><span class="line">        <span class="built_in">let</span> value = input.value</span><br><span class="line">        // console.log(value)</span><br><span class="line">        <span class="built_in">let</span> url = <span class="string">'http://suggestion.baidu.com/su?cb=showJsonp&amp;wd='</span>+value</span><br><span class="line">        <span class="built_in">let</span> script = document.createElement(<span class="string">'script'</span>)</span><br><span class="line">        script.setAttribute(<span class="string">'src'</span>, url)</span><br><span class="line">        script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>)</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure></code></pre><h3 id="2-CORS跨域资源共享"><a href="#2-CORS跨域资源共享" class="headerlink" title="2.CORS跨域资源共享"></a>2.CORS跨域资源共享</h3><blockquote>
<p>有局限性, 而且主要工作在后端</p>
</blockquote>
<ul>
<li>客户端发送axios请求<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// axios进行配置</span><br><span class="line"> - 跨域请求需要带cookie身份验证</span><br><span class="line"> - 默认地址</span><br><span class="line"> - 请求拦截器</span><br><span class="line"> - 相应拦截器</span><br></pre></td></tr></table></figure></li>
<li>服务器端设置相关的头信息(需要处理options试探性请求)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 设置跨域和相应数据格式</span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="keyword">function</span>(req, res, next) &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'X-Requested-With, mytoken'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'X-Requested-With, Authorization'</span>)</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf-8'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,Content-Length, Authorization, Accept,X-Requested-With'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>)</span><br><span class="line">  res.header(<span class="string">'X-Powered-By'</span>, <span class="string">' 3.2.1'</span>)</span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) res.send(200)</span><br><span class="line">  /*让options请求快速返回*/ <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ps局限: 如果使用*号, 可以实现多源配置, 但是就不允许携带cookie了</span><br><span class="line">    不用*号只能有一个具体地址,也就允许cookie了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-proxy"><a href="#3-proxy" class="headerlink" title="3.proxy"></a>3.proxy</h3><blockquote>
<p>纯前端实现跨域, 只能在开发环境中使用, 生产环境需要使用nginx反向代理</p>
</blockquote>
<blockquote>
<p>webpack webpack-cli webpack-dev-server</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  vue中</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    <span class="string">'/'</span>: &#123;</span><br><span class="line">      target: <span class="string">'目标请求地址'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span> // 允许跨域</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">proxy相当于node模拟了一个nginx服务请求, 通过搭建中转服务器来转发请求规避跨越问题 proxy和nginx原理相同</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">开发环境</th>
<th align="left">生产环境</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cors</td>
<td align="left">cors</td>
</tr>
<tr>
<td align="left">proxy</td>
<td align="left">nginx</td>
</tr>
</tbody></table>
<h3 id="4-nginx反向代理"><a href="#4-nginx反向代理" class="headerlink" title="4.nginx反向代理"></a>4.nginx反向代理</h3><blockquote>
<p>需要搭建一个中转nginx服务器用于转发请求, 服务器部署的事</p>
</blockquote>
<blockquote>
<p><a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a> -&gt; <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a></p>
</blockquote>
<blockquote>
<p>nginx目录下的nginx.conf修改</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.a.com; <span class="comment"># 指定的源</span></span><br><span class="line">    access_log  logs/test.access.log;</span><br><span class="line">    <span class="comment"># 匹配以/apis/开头的请求</span></span><br><span class="line">    location ^~ /apis/ &#123;</span><br><span class="line">      proxy_pass http://www.b.com/;  <span class="comment">#注意域名后有一个/  需要反向代理的源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他的跨域解决办法"><a href="#其他的跨域解决办法" class="headerlink" title="其他的跨域解决办法"></a>其他的跨域解决办法</h2><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><blockquote>
<p>postMessage是H5新的API</p>
</blockquote>
<blockquote>
<p>不同域页面间的消息传递 <a href="http://www.a.com/a.html-&gt;www.b.com/b.com" target="_blank" rel="noopener">www.a.com/a.html-&gt;www.b.com/b.com</a></p>
</blockquote>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><blockquote>
<p>需要借助iframe标签</p>
</blockquote>
<h3 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h3><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><blockquote>
<p>Websocket没有跨域限制</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/54270776" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/02/29/Hexo/hexo%E4%B8%ADMarkdown%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="hexo搭建播客"><a href="#hexo搭建播客" class="headerlink" title="hexo搭建播客"></a>hexo搭建播客</h2><blockquote>
<p>Markdown使用 </p>
</blockquote>
<a id="more"></a>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th align="left">列1</th>
<th align="center">列2</th>
<th align="right">列3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">偏左</td>
<td align="center">中间</td>
<td align="right">偏右</td>
</tr>
<tr>
<td align="left">偏左</td>
<td align="center">中间</td>
<td align="right">偏右</td>
</tr>
</tbody></table>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ol>
<li>网络图片形式<br><code>![图片描述](网络地址)</code><br><img src="http://img4.imgtn.bdimg.com/it/u=2694077262,570031060&fm=26&gp=0.jpg" alt=""></li>
<li>文件夹图片<br><code>![](images/avatar.jpg)</code><br><img src="../images/avatar.jpg" alt=""></li>
<li>img标签<img src="http://img4.imgtn.bdimg.com/it/u=2694077262,570031060&fm=26&gp=0.jpg" width="200px"/>

</li>
</ol>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><code>[]()</code><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a><br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo中文文档</a><br><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">theme-next使用文档</a><br><a href="https://sphard.com/ebooks/hexo-next-2/hexo/picture.html" target="_blank" rel="noopener">!!!</a><br><a href="http://guozet.me/post/Use-Hexo-to-built-my-Blog/" target="_blank" rel="noopener">参考</a></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><div class="note defalut">
            <p>defalut  </p>
          </div>
<div class="note primary">
            <p>primary  </p>
          </div>
<div class="note success">
            <p>success  </p>
          </div>
<div class="note info">
            <p>info  </p>
          </div>
<div class="note warning">
            <p>warning  </p>
          </div>
<div class="note danger">
            <p>danger </p>
          </div>



<h3 id="添加百度谷歌收录"><a href="#添加百度谷歌收录" class="headerlink" title="添加百度谷歌收录"></a>添加百度谷歌收录</h3><ul>
<li>在百度搜搜引擎中查看自己域名是否被收录 site:shengrenwu.github.io<ul>
<li><a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度站长</a></li>
</ul>
</li>
<li>然后点击提交网址，并在百度站长中提交申请，并验证网站：</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>theme-next</tag>
      </tags>
  </entry>
</search>
