<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>javascript运行机制</title>
    <url>/2020/03/04/js/javascript%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="javascript单线程"><a href="#javascript单线程" class="headerlink" title="javascript单线程"></a>javascript单线程</h3><p><a href="https://blog.csdn.net/function__/article/details/80883084" target="_blank" rel="noopener">线程问题</a> </p>
<h3 id="javascript同步异步机制"><a href="#javascript同步异步机制" class="headerlink" title="javascript同步异步机制"></a>javascript同步异步机制</h3><a id="more"></a>
<blockquote>
<p><font color=red><strong>同步</strong>:</font>  在一个线程上(主栈/主任务队列)同一时间只能做一件事, 当事情完成后才能进行下一个事情(先把一个任务进栈执行, 执行完成, 再把下一个任务进栈, 上一个任务出栈)</p>
</blockquote>
<blockquote>
<p><font color=red><strong>异步</strong>:</font>  在主栈中执行一个任务, 但是发现这个任务是一个异步的操作, 会把它移出主栈, 放入等待任务队列中(此时浏览器会分配其他线程监听异步任务是否达到指定的执行时间), 如果主栈任务完成, 监听者会把到达时间的异步任务重新放到主栈中执行</p>
</blockquote>
<p>执行机制如图:<br><img src="/images/execute.jpg" width="400px"/></p>
<h4 id="常见异步"><a href="#常见异步" class="headerlink" title="常见异步"></a>常见异步</h4><ul>
<li>宏任务<ul>
<li>整体代码script</li>
<li>定时器(setTimeout, setInterval)</li>
<li>事件绑定</li>
<li>ajax</li>
<li>回调函数</li>
</ul>
</li>
<li>微任务 <ul>
<li>Promise(async/await)</li>
<li>process.nextTick(callback)</li>
</ul>
</li>
</ul>
<h4 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h4><blockquote>
<p>事件循环的顺序, 决定js代码执行的顺序</p>
</blockquote>
<blockquote>
<p>进入整体代码(宏任务)后, 开始第一次循环。接着执行所有的微任务。然后再进入宏任务, 找到其中一个任务队列执行完毕, 再执行所有的微任务。</p>
</blockquote>
<p>代码演示:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setTimeout'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'promise'</span>)</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'then'</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'console'</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li><p>整个代码作为宏任务, 进入主线程</p>
</li>
<li><p>先遇到setTimeout, 将他的回调函数注册后分发到宏任务等待队列</p>
</li>
<li><p>然后遇到new Promise立即执行, then函数分发到微任务等待队列</p>
</li>
<li><p>console.log() 立即执行</p>
</li>
<li><p>整体代码script作为第一个宏任务执行结束, 接着执行遇到的微任务, then函数在微任务的等待队列中执行</p>
</li>
<li><p>第一轮事件循环结束, 开始第二轮。从宏任务的等待队列开始, 执行setTimeout中的回调函数</p>
</li>
<li><p>第二轮没有微任务, 之后也没有宏任务, 结束</p>
<p>事件循环, 宏任务, 微任务关系如下图:</p>
<img src="/images/event loop.jpg" width="500px"/>

</li>
</ul>
<h4 id="题目积累"><a href="#题目积累" class="headerlink" title="题目积累"></a>题目积累</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 复杂题</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'1'</span>);</span><br><span class="line">			</span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'2'</span>);</span><br><span class="line">        process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'3'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'4'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'5'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">2000</span>)</span><br><span class="line">    process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'6'</span>);</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'7'</span>);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'8'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'9'</span>);</span><br><span class="line">        process.nextTick(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'10'</span>);</span><br><span class="line">        &#125;)</span><br><span class="line">        <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'11'</span>);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'12'</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line"><span class="comment">//  1 7  script整体宏任务 </span></span><br><span class="line"><span class="comment">//  6 8  执行所有微任务</span></span><br><span class="line"><span class="comment">//  9 11   两个setTimeout, 后一个时间短(1000)所以先执行第二个setTimeout宏任务</span></span><br><span class="line"><span class="comment">//  10 12  第二个宏任务的微任务</span></span><br><span class="line"><span class="comment">//  2 4  第一个setTimeout(2000)的宏任务</span></span><br><span class="line"><span class="comment">//  3 5  微任务</span></span><br><span class="line"><span class="comment">//  结束</span></span><br></pre></td></tr></table></figure>

<p>带有async/await</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">AA</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">		setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">			<span class="built_in">Math</span>.random() &lt; <span class="number">0.5</span> ? reject(<span class="number">100</span>): resolve(<span class="number">200</span>);</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">	<span class="keyword">let</span> res = <span class="keyword">await</span> AA();</span><br><span class="line">	<span class="comment">/* </span></span><br><span class="line"><span class="comment">	 * 1.先把AA执行，返回一个Promise实例</span></span><br><span class="line"><span class="comment">	 * 2.它会暂时跳出当前正在执行的函数，将后面的代码放到等待队列</span></span><br><span class="line"><span class="comment">	 * 3.主栈暂时空闲</span></span><br><span class="line"><span class="comment">	 * 4.当主栈的其他任务完成，并且AA中的Promise也已经计算完成最后的结果，再把之前的第二步放到等待队列的内容，拿回主栈执行</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">fn();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>有关于setTimeout</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 正常的执行 4 2 3 1</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 添加阻隔 4 2 1 3</span></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">  &#125;, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>)</span><br><span class="line">  &#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.time(<span class="string">'W'</span>);</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i &lt; <span class="number">99999999</span>)&#123;</span><br><span class="line">    i++;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.timeEnd(<span class="string">'W'</span>);<span class="comment">//时间 -&gt; 279ms -&gt; 0.279s</span></span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">  &#125;, <span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2020/03/04/js/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><blockquote>
<p>触发高频事件后n秒内函数只会执行一次, 如果n秒内高频事件再次被触发, 则重新计算时间</p>
</blockquote>
<blockquote>
<p>触发高频事件时在最后一次事件被触发n秒后执行函数</p>
</blockquote>
<a id="more"></a>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// 防抖函数</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">debounce</span>(<span class="params">fn, wait</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> timer = <span class="literal">null</span> <span class="comment">// 创建一个标记用来存放定时器的返回值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>) =&gt;</span> &#123;</span><br><span class="line">      clearTimeout(timer) <span class="comment">// 每当用户输入的时候把前一个setTimeout 清除掉</span></span><br><span class="line">      timer = <span class="built_in">window</span>.setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args) <span class="comment">// this -&gt; window  因为fn函数是在window下创建的, 需要保证this指向</span></span><br><span class="line">      &#125;, wait)</span><br><span class="line">    &#125;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 获取输入框值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!e.target.value) <span class="keyword">return</span> </span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现防抖</span></span><br><span class="line">ipt.addEventListener(<span class="string">'input'</span>, debounce(getValue, <span class="number">2000</span>))</span><br></pre></td></tr></table></figure>
<p>防抖应用场景</p>
<ul>
<li>搜索框</li>
<li>表单验证</li>
<li>按钮提交事件</li>
<li>浏览器窗口缩resize事件<h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><blockquote>
<p>高频事件触发, 但是在n秒只会执行一次</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>节流会稀释函数的执行频率, 固定时间内只执行一次</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 节流函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">fn, delay</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function">(<span class="params">...args</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(!flag) <span class="keyword">return</span></span><br><span class="line">      flag = <span class="literal">false</span></span><br><span class="line">      setTimeout(<span class="function"><span class="params">()</span>=&gt;</span>&#123;</span><br><span class="line">        fn.apply(<span class="keyword">this</span>, args)</span><br><span class="line">        flag = <span class="literal">true</span></span><br><span class="line">      &#125;, delay)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取输入框值的函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getValue</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!e.target.value) <span class="keyword">return</span> </span><br><span class="line">    <span class="built_in">console</span>.log(e.target.value)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 实现节流</span></span><br><span class="line">ipt.addEventListener(<span class="string">'input'</span>, throttle(getValue, <span class="number">1000</span>))</span><br></pre></td></tr></table></figure>
<p>节流应用场景</p>
<ul>
<li>按钮点击事件</li>
<li>拖拽事件</li>
<li>onScroll</li>
<li>计算鼠标移动距离(onmousemove)</li>
</ul>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>跨域</title>
    <url>/2020/03/02/js/%E8%B7%A8%E5%9F%9F/</url>
    <content><![CDATA[<h2 id="跨域是什么"><a href="#跨域是什么" class="headerlink" title="跨域是什么"></a>跨域是什么</h2><ul>
<li>同源策略请求( 协议,域名,端口号都相同 )</li>
<li>非同源策略请求( 协议,域名,端口号有一个不同就是跨域 )<a id="more"></a>

</li>
</ul>
<h2 id="跨域解决方法"><a href="#跨域解决方法" class="headerlink" title="跨域解决方法"></a>跨域解决方法</h2><h3 id="1-JSONP"><a href="#1-JSONP" class="headerlink" title="1.JSONP"></a>1.JSONP</h3><blockquote>
<p>script, img, iframe标签中的src属性是没有同源策略限制的, 例如借用CDN使用jquery库</p>
</blockquote>
<pre><code>JQ中使用Jsonp: 请求时添加dataType: &apos;jsonp&apos;属性来指定请求方式
Vue使用Jsonp: 下载jsonp依赖进行jsonp请求
JSONP原理: 前端创建一个回调函数, 然后服务器调用这个函数并且将JSON数据作为参数传递, 完成回调
JSONP总结: 兼容性非常好, 限制就是只能使用get方式发起请求(因为src, href都是资源文件请求), 安全性也存在问题
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// 使用jsonp的方式动态创建script标签实现jsonp跨域请求</span><br><span class="line">// 实现百度搜索关键词的功能</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;input <span class="built_in">type</span>=<span class="string">"text"</span> id=<span class="string">"input"</span>&gt;</span><br><span class="line">    &lt;button id=<span class="string">"btn"</span>&gt;搜索&lt;/button&gt;</span><br><span class="line">    &lt;ul id=<span class="string">"ul"</span> style=<span class="string">"list-style-type: none;padding: 0"</span>&gt;</span><br><span class="line">      &lt;!-- &lt;li&gt;搜索到的值&lt;/li&gt; --&gt;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">    &lt;script <span class="built_in">type</span>=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      // http://api.asilu.com/<span class="comment">#sug-baidu jsonp在线接口</span></span><br><span class="line">      <span class="keyword">function</span> showJsonp(res)&#123;</span><br><span class="line">        console.log(res) // &#123;q: <span class="string">"123"</span>, p: <span class="literal">false</span>, s: Array(10)&#125;</span><br><span class="line">        <span class="built_in">let</span> data = res.s</span><br><span class="line">        // 将res.s中的数据渲染到li标签中</span><br><span class="line">        <span class="built_in">let</span> str = <span class="string">''</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">let</span> i =0; i&lt;data.length; i++)&#123;</span><br><span class="line">          str += `&lt;li class=<span class="string">"active"</span>&gt;<span class="variable">$&#123;data[i]&#125;</span>&lt;/li&gt;`</span><br><span class="line">        &#125;</span><br><span class="line">        // 添加到ul标签内部</span><br><span class="line">        ul.innerHTML = str</span><br><span class="line">      &#125;</span><br><span class="line">      btn.onclick = <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">        // 点击搜索时获取输入框的值</span><br><span class="line">        <span class="built_in">let</span> value = input.value</span><br><span class="line">        // console.log(value)</span><br><span class="line">        <span class="built_in">let</span> url = <span class="string">'http://suggestion.baidu.com/su?cb=showJsonp&amp;wd='</span>+value</span><br><span class="line">        <span class="built_in">let</span> script = document.createElement(<span class="string">'script'</span>)</span><br><span class="line">        script.setAttribute(<span class="string">'src'</span>, url)</span><br><span class="line">        script.setAttribute(<span class="string">'type'</span>, <span class="string">'text/javascript'</span>)</span><br><span class="line">        document.body.appendChild(script)</span><br><span class="line">      &#125;</span><br><span class="line">   &lt;/script&gt;</span><br><span class="line"> &lt;/body&gt;</span><br></pre></td></tr></table></figure></code></pre><h3 id="2-CORS跨域资源共享"><a href="#2-CORS跨域资源共享" class="headerlink" title="2.CORS跨域资源共享"></a>2.CORS跨域资源共享</h3><blockquote>
<p>有局限性, 而且主要工作在后端</p>
</blockquote>
<ul>
<li>客户端发送axios请求<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// axios进行配置</span><br><span class="line"> - 跨域请求需要带cookie身份验证</span><br><span class="line"> - 默认地址</span><br><span class="line"> - 请求拦截器</span><br><span class="line"> - 相应拦截器</span><br></pre></td></tr></table></figure></li>
<li>服务器端设置相关的头信息(需要处理options试探性请求)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">// 设置跨域和相应数据格式</span><br><span class="line">app.all(<span class="string">'*'</span>, <span class="keyword">function</span>(req, res, next) &#123;</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Origin'</span>, <span class="string">'*'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'X-Requested-With, mytoken'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'X-Requested-With, Authorization'</span>)</span><br><span class="line">  res.setHeader(<span class="string">'Content-Type'</span>, <span class="string">'application/json;charset=utf-8'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Headers'</span>, <span class="string">'Content-Type,Content-Length, Authorization, Accept,X-Requested-With'</span>)</span><br><span class="line">  res.header(<span class="string">'Access-Control-Allow-Methods'</span>, <span class="string">'PUT,POST,GET,DELETE,OPTIONS'</span>)</span><br><span class="line">  res.header(<span class="string">'X-Powered-By'</span>, <span class="string">' 3.2.1'</span>)</span><br><span class="line">  <span class="keyword">if</span> (req.method == <span class="string">'OPTIONS'</span>) res.send(200)</span><br><span class="line">  /*让options请求快速返回*/ <span class="keyword">else</span> next()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">ps局限: 如果使用*号, 可以实现多源配置, 但是就不允许携带cookie了</span><br><span class="line">    不用*号只能有一个具体地址,也就允许cookie了</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="3-proxy"><a href="#3-proxy" class="headerlink" title="3.proxy"></a>3.proxy</h3><blockquote>
<p>纯前端实现跨域, 只能在开发环境中使用, 生产环境需要使用nginx反向代理</p>
</blockquote>
<blockquote>
<p>webpack webpack-cli webpack-dev-server</p>
</blockquote>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">  vue中</span><br><span class="line">  proxy: &#123;</span><br><span class="line">    <span class="string">'/'</span>: &#123;</span><br><span class="line">      target: <span class="string">'目标请求地址'</span>,</span><br><span class="line">      changeOrigin: <span class="literal">true</span> // 允许跨域</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">proxy相当于node模拟了一个nginx服务请求, 通过搭建中转服务器来转发请求规避跨越问题 proxy和nginx原理相同</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">开发环境</th>
<th align="left">生产环境</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cors</td>
<td align="left">cors</td>
</tr>
<tr>
<td align="left">proxy</td>
<td align="left">nginx</td>
</tr>
</tbody></table>
<h3 id="4-nginx反向代理"><a href="#4-nginx反向代理" class="headerlink" title="4.nginx反向代理"></a>4.nginx反向代理</h3><blockquote>
<p>需要搭建一个中转nginx服务器用于转发请求, 服务器部署的事</p>
</blockquote>
<blockquote>
<p><a href="http://www.b.com" target="_blank" rel="noopener">www.b.com</a> -&gt; <a href="http://www.a.com" target="_blank" rel="noopener">www.a.com</a></p>
</blockquote>
<blockquote>
<p>nginx目录下的nginx.conf修改</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80;</span><br><span class="line">    server_name  www.a.com; <span class="comment"># 指定的源</span></span><br><span class="line">    access_log  logs/test.access.log;</span><br><span class="line">    <span class="comment"># 匹配以/apis/开头的请求</span></span><br><span class="line">    location ^~ /apis/ &#123;</span><br><span class="line">      proxy_pass http://www.b.com/;  <span class="comment">#注意域名后有一个/  需要反向代理的源</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="其他的跨域解决办法"><a href="#其他的跨域解决办法" class="headerlink" title="其他的跨域解决办法"></a>其他的跨域解决办法</h2><h3 id="postMessage"><a href="#postMessage" class="headerlink" title="postMessage"></a>postMessage</h3><blockquote>
<p>postMessage是H5新的API</p>
</blockquote>
<blockquote>
<p>不同域页面间的消息传递 <a href="http://www.a.com/a.html-&gt;www.b.com/b.com" target="_blank" rel="noopener">www.a.com/a.html-&gt;www.b.com/b.com</a></p>
</blockquote>
<h3 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h3><blockquote>
<p>需要借助iframe标签</p>
</blockquote>
<h3 id="location-hash"><a href="#location-hash" class="headerlink" title="location.hash"></a>location.hash</h3><h3 id="Websocket"><a href="#Websocket" class="headerlink" title="Websocket"></a>Websocket</h3><blockquote>
<p>Websocket没有跨域限制</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/54270776" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>我的第一篇博客</title>
    <url>/2020/02/29/hexo/hexo%E4%B8%ADMarkdown%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="hexo搭建播客"><a href="#hexo搭建播客" class="headerlink" title="hexo搭建播客"></a>hexo搭建播客</h2><blockquote>
<p>Markdown使用 </p>
</blockquote>
<a id="more"></a>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><table>
<thead>
<tr>
<th align="left">列1</th>
<th align="center">列2</th>
<th align="right">列3</th>
</tr>
</thead>
<tbody><tr>
<td align="left">偏左</td>
<td align="center">中间</td>
<td align="right">偏右</td>
</tr>
<tr>
<td align="left">偏左</td>
<td align="center">中间</td>
<td align="right">偏右</td>
</tr>
</tbody></table>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ol>
<li>网络图片形式<br><code>![图片描述](网络地址)</code><br><img src="http://img4.imgtn.bdimg.com/it/u=2694077262,570031060&fm=26&gp=0.jpg" alt=""></li>
<li>文件夹图片<br><code>![](images/avatar.jpg)</code><br><img src="../images/avatar.jpg" alt=""></li>
<li>img标签<img src="http://img4.imgtn.bdimg.com/it/u=2694077262,570031060&fm=26&gp=0.jpg" width="200px"/>

</li>
</ol>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><p><code>[]()</code><br><a href="http://baidu.com" target="_blank" rel="noopener">百度</a><br><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">hexo中文文档</a><br><a href="https://theme-next.iissnan.com/" target="_blank" rel="noopener">theme-next使用文档</a><br><a href="https://sphard.com/ebooks/hexo-next-2/hexo/picture.html" target="_blank" rel="noopener">!!!</a><br><a href="http://guozet.me/post/Use-Hexo-to-built-my-Blog/" target="_blank" rel="noopener">参考</a></p>
<h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><div class="note defalut">
            <p>defalut  </p>
          </div>
<div class="note primary">
            <p>primary  </p>
          </div>
<div class="note success">
            <p>success  </p>
          </div>
<div class="note info">
            <p>info  </p>
          </div>
<div class="note warning">
            <p>warning  </p>
          </div>
<div class="note danger">
            <p>danger </p>
          </div>



<h3 id="添加百度谷歌收录"><a href="#添加百度谷歌收录" class="headerlink" title="添加百度谷歌收录"></a>添加百度谷歌收录</h3><ul>
<li>在百度搜搜引擎中查看自己域名是否被收录 site:shengrenwu.github.io<ul>
<li><a href="https://ziyuan.baidu.com/" target="_blank" rel="noopener">百度站长</a></li>
</ul>
</li>
<li>然后点击提交网址，并在百度站长中提交申请，并验证网站：</li>
</ul>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>theme-next</tag>
      </tags>
  </entry>
</search>
